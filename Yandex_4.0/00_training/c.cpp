/*
C. Путешествие по Москве
Мэрия Москвы основательно подготовилась к празднованию тысячелетия города в 2147 году, построив под столицей бесконечную асфальтированную площадку, чтобы заменить все существующие в городе автомобильные дороги. В память о кольцевых и радиальных дорогах разрешили двигаться по площадке только двумя способами:
1. В сторону точки начала координат или от неё. При этом из точки начала координат разрешено двигаться в любом направлении.
2. Вдоль окружности с центром в начале координат и радиусом, который равен текущему расстоянию до начала координат. Двигаться вдоль такой окружности разрешается в любом направлении (по или против часовой стрелки).
Вам, как ведущему программисту ответственной инстанции поручено разработать модуль, который будет определять кратчайший путь из точки A, с координатами (xA, yA) в точку B с координатами (xB, yB). Считайте, что менять направление движения можно произвольное количество раз, но оно должно всегда соответствовать одному из двух описанных выше вариантов.

Формат ввода
В первой строке ввода заданы четыре целых числа xA, yA, xB и yB, по модулю не превосходящие 10^6.

Формат вывода
Выведите одно число — минимальное расстояние, которое придётся преодолеть по пути из точки A в точку B, если не нарушать правил дорожного движения. Ваш ответ будет принят, если его абсолютная или относительная погрешность не превосходит 10^-6.
*/

#include <iostream>
#include <cmath>
#include <iomanip>

int main()
{
	long double xA, yA, xB, yB;
	std::cin >> xA >> yA >> xB >> yB;

	long double angleA = atan2(yA, xA);
	long double angleB = atan2(yB, xB);
	long double angleDiff = fabs(angleB - angleA);
	long double shortestAngle = std::min(angleDiff, 2 * M_PI - angleDiff);

	long double distanceA = sqrt(xA * xA + yA * yA);
	long double distanceB = sqrt(xB * xB + yB * yB);

	long double arcLength;
	if (distanceA > distanceB)
		arcLength = distanceB * shortestAngle;
	else
		arcLength = distanceA * shortestAngle;

	double minDistance = std::min(distanceA + distanceB, arcLength + fabsl(distanceA - distanceB));

	std::cout << std::fixed << std::setprecision(15) << minDistance << std::endl;
	return 0;
}
