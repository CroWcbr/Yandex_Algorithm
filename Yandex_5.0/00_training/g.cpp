/*
G. Разрушить казарму
Вы играете в интересную стратегию. У вашего соперника остались всего одна казарма — здание, в котором постоянно появляются новые солдаты. Перед атакой у вас есть x солдат. За один раунд каждый солдат может убить одного из солдат противника или нанести 1 очко урона казарме (вычесть единицу здоровья у казармы). Изначально у вашего оппонента нет солдат. Тем не менее, его казарма имеет y единиц здоровья и производит p солдат за раунд.

Ход одного раунда:
1. Каждый солдат из вашей армии либо убивает одного из солдат вашего противника, либо наносит 1 очко урона казарме. Каждый солдат может выбрать своё действие. Когда казарма теряет все свои единицы здоровья, она разрушается.
2. Ваш противник атакует. Он убьет k ваших солдат, где k — количество оставшихся у противника солдат.
3. Если казармы еще не разрушены, ваш противник производит p новых солдат.
Ваша задача — разрушить казарму и убить всех солдат противника. Если это возможно, посчитайте минимальное количество раундов, которое вам нужно для этого. В противном случае выведите -1.

Формат ввода
На вход подаётся три целых числа x, y, p (1 ≤ x, y, p ≤ 5000) — количество ваших солдат на старте игры, количество очков здоровья казармы и количество производимых за раунд казармой солдат, соответственно. Каждое число расположено в новой строке.

Формат вывода
Если возможно убить всех вражеских солдат и разрушить казарму, выведите минимальное количество раундов, необходимых для этого. В противном случае выведите -1.
*/

#include <iostream>
#include <cmath>

int check(int x, int y, int p, int k)
{
    int step = 0;
    while (y > 0 || k > 0)
    {
        // std::cout << "\t" << step << "\t" << x << "\t" << y << "\t" << k << std::endl;
        if (y == 0)
            k -= x;
        else if (y >= x)
            y -= x;
        else
        {
            k -= (x - y);
            y = 0;
        }
        x -= k;
        if (y > 0)
            k += p;
        if (x <= 0)
            return -1;
        step++;
        // std::cout << "\t" << "\t" << x << "\t" << y << "\t" << k << std::endl;
    }
    return step;
}

int main()
{
	int x, y, p;
	std::cin >> x >> y >> p;

    int result = 0;
    int tmp_result = -1;
    int k = 0;

    while (y > 0 || k > 0)
    {
        // std::cout << result << "\t" << x << "\t" << y << "\t" << k << std::endl;
        if (y > 0 && x <= k)
        {
            result = tmp_result;
            break;
        }

        int tmp = check(x, y, p, k);
        // std::cout << tmp << "\t" << std::endl;
        if (tmp > 0)
            if (tmp_result > result + tmp || tmp_result == -1)
                tmp_result = result + tmp;

        y -= (x - k);
        k = 0;

        x -= k;
        if (x <= 0)
        {
            result = tmp_result;
            break;
        }

        if (y > 0)
            k += p;
        
        result++;
        // std::cout << "\t" << x << "\t" << y << "\t" << k << std::endl;
    }

    std::cout << (tmp_result == -1 ? result : std::min(tmp_result, result)) << std::endl;
    return 0;
}