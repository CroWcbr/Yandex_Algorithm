/*
H. Спички детям не игрушка!
Вася любит решать головоломки со спичками. Чаще всего они формулируется следующим образом: дано изображение A, составленное из спичек; переложите в нем минимальное количество спичек так, чтобы получилось изображение B.
Например, из номера текущего командного чемпионата школьников Санкт-Петербурга по программированию, можно получить ромб с диагональю, переложив всего три спички.
Головоломки, которые решает Вася, всегда имеют решение. Это значит, что набор спичек, используемый в изображении A, совпадает с набором спичек, используемым в изображении B. Кроме того, в одном изображении никогда не встречаются две спички, у которых есть общий участок ненулевой длины (то есть спички могут пересекаться, но не могут накладываться друг на друга).
Вася устал решать головоломки вручную, и теперь он просит вас написать, программу, которая будет решать головоломки за него. Программа будет получать описания изображений A и B и должна найти минимальное количество спичек, которые надо переложить в изображении A, чтобы полученная картинка получалась из B параллельным переносом.

Формат ввода
В первой строке входного файла содержится целое число n — количество спичек в каждом из изображений (1 ≤ n ≤ 1000).
В следующих n строках записаны координаты концов спичек на изображении A. Спичка номер i описывается целыми числами x1i, y1i, x2i, y2i — координатами ее концов. Следующие n строк содержат описание изображения B в таком же формате. Набор длин этих спичек совпадает с набором длин спичек с изображения A.
Все координаты по абсолютной величине не превосходят 104. Все спички имеют ненулевую длину, то есть x1i ≠ x2i или y1i ≠ y2i.

Формат вывода
Выведите в выходной файл минимальное количество спичек, которые следует переложить, чтобы изображение A совпало с изображением B, с точностью до параллельного переноса.

*/

#include <iostream>
#include <fstream>
#include <unordered_map>
#include <vector>

struct Point
{
    int x;
    int y;
    int x_v;
    int y_v;
};

void read_input(std::ifstream& input,
                int n,
				std::vector<Point>& line)
{
    int x1, y1, x2, y2;
    for (int i = 0; i < n; ++i)
    {
        input >> x1 >> y1 >> x2 >> y2;
        if (x1 > x2 || (x2 == x1 && y1 > y2))
        {
            std::swap(x1, x2);
            std::swap(y1, y2);
        }
        x1 += 10000;
        y1 += 10000;
        x2 += 10000;
        y2 += 10000;
        line[i] = {x1, y1, x2 - x1, y2 - y1};
    }
}

size_t my_key(int x, int y)
{
    return x * 20000 + y;
}

int main()
{
	std::ifstream input("input.txt");
	int n;
	input >> n;
    std::vector<Point> first_line(n);
    std::vector<Point> second_line(n);
	read_input(input, n, first_line);
    read_input(input, n, second_line);
	input.close();

    std::unordered_map<int, int> ans;
    for (auto& f : first_line)
        for (auto& v : second_line)
            if (f.x_v == v.x_v && f.y_v == v.y_v)
                ans[my_key(v.x - f.x, v.y - f.y)] += 1;

    int answer = 0;
    for (const auto& pair : ans)
        if (pair.second > answer)
            answer = pair.second;
    std::cout << n - answer << std::endl;

    return 0;
}
