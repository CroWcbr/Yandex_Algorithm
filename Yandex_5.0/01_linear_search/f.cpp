/*
F. Колесо Фортуны
Развлекательный телеканал транслирует шоу «Колесо Фортуны». В процессе игры участники шоу крутят большое колесо, разделенное на сектора. В каждом секторе этого колеса записано число. После того как колесо останавливается, специальная стрелка указывает на один из секторов. Число в этом секторе определяет выигрыш игрока.
Юный участник шоу заметил, что колесо в процессе вращения замедляется из-за того, что стрелка задевает за выступы на колесе, находящиеся между секторами. Если колесо вращается с угловой скоростью v градусов в секунду, и стрелка, переходя из сектора X к следующему сектору, задевает за очередной выступ, то текущая угловая скорость движения колеса уменьшается на k градусов в секунду. При этом если v ≤ k, то колесо не может преодолеть препятствие и останавливается. Стрелка в этом случае будет указывать на сектор X.
Юный участник шоу собирается вращать колесо. Зная порядок секторов на колесе, он хочет заставить колесо вращаться с такой начальной скоростью, чтобы после остановки колеса стрелка указала на как можно большее число. Колесо можно вращать в любом направлении и придавать ему начальную угловую скорость от a до b градусов в секунду.
Требуется написать программу, которая по заданному расположению чисел в секторах, минимальной и максимальной начальной угловой скорости вращения колеса и величине замедления колеса при переходе через границу секторов вычисляет максимальный выигрыш.

Формат ввода
Первая строка входного файла содержит целое число n — количество секторов колеса (3 ≤ n ≤ 100).
Вторая строка входного файла содержит n положительных целых чисел, каждое из которых не превышает 1000 — числа, записанные в секторах колеса. Числа приведены в порядке следования секторов по часовой стрелке. Изначально стрелка указывает на первое число.
Третья строка содержит три целых числа: a, b и k (1 ≤ a ≤ b ≤ 10^9, 1 ≤ k ≤ 10^9).

Формат вывода
В выходном файле должно содержаться одно целое число — максимальный выигрыш.
*/

#include <iostream>
#include <vector>

int find_max_right(const std::vector<int>& data, int i1, int i2)
{
    int max = 0;

    for (; i1 != i2 + 1; ++i1)
    {
        if (i1 == data.size())
            i1 = 0;
        if (data[i1] > max)
            max = data[i1];
    }
    return max;
}

int main()
{
	int n;
	std::cin >> n;
    
    std::vector<int> data(n);
    for (int i = 0; i < n; ++i)
        std::cin >> data[i];

    int a, b, k;
    std::cin >> a >> b >> k;

    int min_right, min_left, max_right, max_left;
    min_right = (a / k - (a >= k && a % k == 0));
    max_right = (b / k - (b >= k && b % k == 0));

    // std::cout << min_right << "\t" << max_right << std::endl;
    if (max_right - min_right >= n - 1 || max_left - min_left >= n - 1)
        std:: cout << find_max_right(data, 0, n - 1) << std::endl;
    else
    {
        min_right %= n;
        max_right %= n;
 
        min_left = ((n - max_right) >= data.size() ? 0 : (n - max_right));
        max_left = ((n - min_right) >= data.size() ? 0 : (n - min_right));
        // std::cout << min_right << "\t" << max_right << std::endl;
        // std::cout << min_left << "\t" << max_left << std::endl;
        std:: cout << std::max(find_max_right(data, min_right, max_right), find_max_right(data, min_left, max_left)) << std::endl;
    }

    return 0;
}


