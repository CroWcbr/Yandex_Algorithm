'''
F. Велодорожки
Мэр одного города очень любит следить за тенденциями и воспроизводить их в своём городе. До него дошла новость о популярности велодорожек. Теперь он хочет проложить велодорожки в своём городе и сделать это лучше, чем в других городах! Поэтому он решил сделать велодорожки даже на главной площади города.
Главная площадь представляет собой прямоугольник шириной w и высотой h, замощённый квадратными плитками со стороной 1. Мэр хочет, чтобы было проложено две велодорожки одинаковой ширины: одна горизонтальная и одна вертикальная. К сожалению, ремонт на площади проводился достаточно давно и на некоторых плитках уже появились трещины. Мэр хочет проложить велодорожки так, чтобы после этого на площади остались только целые плитки. При строительстве велодорожек плитки на их месте убираются. Можно только убирать плитки с площади и нельзя менять местами или добавлять новые. Чтобы потратить меньше денег, мэр хочет сделать велодорожки наименьшей возможной ширины, при этом ширина дорожек должна быть целым числом. Определите, какой должна быть ширина велодорожек.

Формат ввода
В первой строке входных данных содержатся три целых числа w,h,n (1≤w,h≤10^9,1≤n≤min(w×h,3⋅10^5))  — ширина и высота площади и количество потрескавшихся плиток соответственно.
В следующих n строках содержится по 2 целых числа xi,yi (1≤xi≤w,1≤yi≤h)  — координаты потрескавшихся плиток. (xi,yi)≠(xj,yj) при i≠j.

Формат вывода
Выведите единственное число c (1≤c≤min(w,h)) — наименьшую возможную ширину велодорожек.
'''

# !!!!не мое решение!!!!, решение с яндекс контекста

def check(m):
    r = 0
    pmx = -10**9
    pmn = 10**9
    for i in range(n):
        while r < n and x[r] < x[i] + m:
            r += 1
        mx = pmx
        mn = pmn
        if r != n:
            mx = max(mx, sufmax[r])
            mn = min(mn, sufmin[r])
        if mx - mn < m:
            return True
        pmx = prefmax[i]
        pmn = prefmin[i]
    return False

with open('input.txt', 'r') as f:
    w, h, n = map(int, f.readline().split())
    a = [tuple(map(int, f.readline().split())) for _ in range(n)]

a.sort()
x = []
y = []
for now in a:
    x.append(now[0])
    y.append(now[1])
prefmin = [y[0]] * n
prefmax = [y[0]] * n
sufmin = [y[-1]] * n
sufmax = [y[-1]] * n
for i in range(1,n):
    prefmin[i] = min(prefmin[i - 1], y[i])
    prefmax[i] = max(prefmax[i - 1], y[i])
for i in range(n - 2, -1, -1):
    sufmin[i] = min(sufmin[i + 1], y[i])
    sufmax[i] = max(sufmax[i + 1], y[i])
l = 0
r = min(w, h)
while l < r:
    m = (l + r) // 2
    if check(m):
        r = m
    else:
        l = m + 1
print(l)
